\documentclass[a4paper,15pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[english, polish]{babel}
\usepackage[utf8]{inputenc}   % lub utf8
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{anysize}
\usepackage{enumerate}
\usepackage{times}
\usepackage{caption}
\usepackage{titlesec}
\usepackage{float}
\usepackage{titleps,kantlipsum}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{framed}
\usepackage{tcolorbox}
\lstloadlanguages{Matlab}
 
\usepackage[justification=centering]{caption}
\titlelabel{\thetitle.\quad}

\pagenumbering{arabic}

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{%
  \parbox{\textwidth}{\colorbox{darkgreen}{\parbox{\textwidth}{#1#2#3}}\vskip-4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep}

% Definicja nowego stylu strony
\newpagestyle{mypage}
{
  \headrule
  
  \sethead
  { \MakeUppercase{\thesection\quad \sectiontitle} } 
  {}
  {\thesubsection\quad \subsectiontitle}
  
  \setfoot
  {}
  {}
  {\thepage}
}

\newpagestyle{mypage_1}
{
	\headrule
	
	\sethead
	{  }
	{\MakeUppercase{Extreme Programming}}
	{}
	
	\setfoot
	{}
	{\thepage}
	{}
}

\settitlemarks{section,subsection,subsubsection}

\pagestyle{mypage_1}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{mKeyword}{RGB}{0,0,242}
\definecolor{mRed}{RGB}{234,67,53}
\definecolor{backgroundColour}{RGB}{242,242,242}

\newcommand{\definition}[2]{
    \begin{tcolorbox}[colback=green!5!white,colframe=mGreen,title={Definicja -  #1}]
        #2
    \end{tcolorbox}
}

\newcommand{\question}[2]{
    \begin{tcolorbox}[colback=mRed!5!white,colframe=mRed,title={Kolokwium 2018 #1}]
        #2
    \end{tcolorbox}
}

%\marginsize{left}{right}{top}{bottom}
\marginsize{3cm}{3cm}{3cm}{3cm}
\sloppy
\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}[{\titlerule[0.8pt]}]
 
 \definecolor{darkred}{rgb}{0.9,0,0}
\definecolor{grey}{rgb}{0.4,0.4,0.4}
\definecolor{orange}{rgb}{1,0.6,0.05}
\definecolor{darkgreen}{rgb}{0.2,0.5,0.05}
 


\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{mKeyword},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    %captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}


\newcommand{\Hilight}{\makebox[0pt][l]{\color{cyan}\rule[-4pt]{0.65\linewidth}{14pt}}}


\begin{document}

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\multicolumn{3}{|c|}{\textbf{Opracowanie do kolokwium}} \\ \hline \multicolumn{3}{|c|}{Programowanie ekstremalne 2019}  \\ \hline
\end{tabular}
\end{center}
\end{table}

\tableofcontents


\newpage
\section{Źródła}
Opracowanie na podstawie:
\begin{itemize}
\item Wykłady z UPEL
\item Pytania z kolokwium 2018 (wiki.stosowana)
\item http://www.extremeprogramming.org/
\end{itemize}

\section{Spis wykładów chronologicznie}
\begin{enumerate}
\item Metody Zwinne - XPM - Plik pdf: Wykład cz.1
\item XPM testy jednostkowe - Plik pdf: Wykład - Testowanie w XPM
\item Metodyki Zwinne - XPM - Plik pdf: Wykład cz.2
\item XPM Projektowanie zwinne - Plik pdf: Wykład - Projektowanie w XPM
\item Wzorce projektowe dla Agile - Plik pdf: Wykład - Wzorce projektowe w XPM
\end{enumerate}
Było coś jeszcze o refactoringu, ale nie ma nawet tego na UPEL więc pewnie nie łapie się w zakres...

\section{Wykład cz.1}
\subsection{Slajd 1}
\begin{framed}
Czym jest XP ?
\end{framed}
XP należy interpretować jako metodykę zwinną planowania i realizowania projektów informatycznych. 


\begin{framed}
Czym są User Stories ?
\end{framed}
Opisują wymagania systemu(dla bieżącej iteracji), są podstawą do planowania iteracji i budowania testów jednostek.

\begin{framed}
Czym jest Architectural Spike ?
\end{framed} 
Ogólne określenie rozwiązań technologicznych (środowisko, narzędzia) użytych przy wytwarzaniu systemu. Pozwala na wstępną redukcję ryzyka, wynikiem Architectural Spike jest tzw. Spike Solution. 

\begin{framed}
Czym jest System Metaphor ?
\end{framed}
Wstępna koncepcja architektury systemu powstała po analizie Architectual Spike. System Metaphor służy klientowi aby będąc osobą nietechniczną mógł zrozumieć działanie systemu oraz programistom aby mogli lepiej zrozumieć działanie systemu.

\question{}{
Co to jest i do czego służy System Metaphor ?
}

\subsection{Slajd 2}
\begin{framed}
Czym jest Release Planning ? (Release Plan)
\end{framed}
Plan, którego założeniem jest wypuszczenie kolejnej wersji produktu po przejściu określonej liczby iteracji.

\begin{framed}
Po co stosujemy testy w XP ?
\end{framed}
\begin{itemize}
\item Stosowane do walidacji jednostek (testy jednostkowe)
\item Stosowane do zaliczania iteracji zgodnie z Release Plan (testy akceptacyjne)
\end{itemize}


\begin{framed}
Do czego służą testy akceptacyjne ?
\end{framed}
Ich zaliczenie umożliwia prezentację wersji (release) systemu klientowi. Release nie jest obowiązkowy - można przejść do kolejnej iteracji z kolejną user story bez zrobienia releasu, a z zakończonym pozytywnie testem akceptacyjnym.

\begin{framed}
Czym jest small release ?
\end{framed}
Jeśli wersja została zaakceptowana przez klienta, to może zostać wypuszczona, co nazywane jest small release.


\subsection{Slajdy 3,4}
Taka ogólna mapka XP...

\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp1.png}}
\end{figure}

\newpage
Ale ta jest chyba lepsza...
\begin{figure}[H]
\centerline{\includegraphics[scale=1]{xp2.png}}
\end{figure}

\begin{framed}
Czym się kończy iteracja, a co ją poprzedza ?
\end{framed}
\begin{itemize}
\item Iteracja kończy się osiągnięciem działającej wersji systemu (po zakończeniu kodowania), złączeniu i przetestowaniu nowo powstałej wersji systemu. 
\item Przed rozpoczęciem iteracji analizowany jest tzw. architectural spike (według wykładu)
\end{itemize}


\subsection{Slajdy 4-7}
\begin{framed}
Wymień 4 postulaty XP
\end{framed}
\begin{itemize}
\item Planowanie
\item Projektowanie
\item Implementacja
\item Testowanie
\end{itemize}

\begin{framed}
Opisz postulat XP: Planowanie
\end{framed}
Prowadzone jest iteracyjnie, ma na celu wyodrębnić zadania do realizacji w danej iteracji. Zadanie muszą być uproszczone, czyli na tyle małe aby zmieściły się w iteracji. Oszacowania  czasowe  zawsze  ujmuje  się  z dołu,  czyli zakładając iż realizacja zadania potrwa na pewno nie mniej niż  to zostało określone w planie. 

\begin{framed}
Opisz postulat XP: Projektowanie
\end{framed}
\begin{itemize}
\item Projekt funkcjonalności przyszłego systemu, jeśli w ogóle istnieje, to zakłada maksymalną prostotę. 
\item W czasie realizacji poszczególnych iteracji nie dodaje się żadnej zbędnej funkcjonalności.
\item Dodatkową funkcjonalność dodawać będzie można w przyszłości – dopiero wtedy, gdy zajdzie taka potrzeba.
\item Także kod posiadający funkcjonalność nadmiarową na skutek wycofania się klienta z wcześniej stawianych wymagań winien być z niej oczyszczony.
\end{itemize}


\begin{framed}
Opisz postulat XP: Implementacja
\end{framed}
Metodyka XP ingeruje silnie w kwestie tworzenia kodu implementowanego systemu. Definiuje szereg wytycznych, postulujących między innymi:
\begin{itemize}
\item Utrzymywanie ściśle określonej konwencji kodowania, 
\item Ciągłe definiowanie testów tworzonego kodu (jeszcze przed jego utworzeniem),
\item Często prowadzoną integrację kodu,
\item Programowanie w parach, 
\item Współdzielenie kodu przez wszystkich członków zespołu
\end{itemize}


\begin{framed}
Opisz postulat XP: Testowanie
\end{framed}
\begin{itemize}
\item System  testowania  tworzonego  kodu  jest  sztandarowym atrybutem  programowania  ekstremalnego,  odróżniającym  tą metodykę od innych jest nacisk postawiony na testowanie. 
\item Testy są definiowane nawet zanim powstanie kod, swoją treścią przybliżając zakres przyszłej funkcjonalności systemu. 
\item Kod  jest  umieszczany  w  ogólnodostępnym  dla  zespołu repozytorium dopiero po przejściu testów
\item Te  same  testy  są  prowadzone  po  zintegrowaniu  kodu,  jego rozszerzeniu funkcjonalnym czy refaktoryzacji
\item Testy  są  również  środkiem  zapobiegającym  nawrotom  już wykrytych i usuniętych błędów w oprogramowaniu, po usunięciu błędu tworzony jest test.
\end{itemize}

\subsection{Slajdy 9-16}
\begin{framed}
Co robi programista w XP ?
\end{framed}
Podobnie jak w innych metodykach zajmuje się wytwarzaniem kodu realizującego konkretną funkcjonalność. \\ Inaczej niż w innych metodykach, jest on odpowiedzialny za całość wytwarzanego kodu więc jego zakres kompetencji jest większy. Programista odpowiada dodatkowo za pisanie testów jednostkowych, wydzielanie zadań z historyjek oraz ich estymację, refaktoryzacje kodu.
\question{}{
Jak różni się rola Programista w XP od metodyk klasycznych ?
}

\begin{framed}
Co robi tester w XP ?
\end{framed}
Tester nie jest jedynie przeciwwagą dla programisty, pełni szerszą rolę. Dostarcza informację o wynikach prowadzonych periodycznie testów. Tester współpracuje z programistami w wytwarzaniu oprogramowania oraz z klientem przy tworzeniu testów, co pozwala uzyskać informację uzupełniającą nt. wymagań.

\begin{framed}
Co robi klient w XP ?
\end{framed}
Dostarcza podstawowej informacji o wymaganiach. Współpracuje z testerem w dziedzinie tworzenia testów (lub nawet tworzy je sam). Posiada najbardziej autorytatywną wiedzę nt. zasad funkcjonowania systemu. Dokonuje oględzin gotowych wersji produktu.

\begin{framed}
Na jakie role można podzielić klienta ? Opisz każdą z ról.
\end{framed}
\begin{itemize}
\item Storytellers (Goal Donor) - mają wiedzę o działaniu systemu, definiują wymagania 
\item Acceptors - użytkownicy systemu, przeprowadzają testy akceptacyjne
\item Gold Owners - podstawowe źródło finansowania projektu, inwestor
\item Planners - pracują nad zdefiniowaniem i zarządzaniem wdrożeniem systemu
\item Big Boss - dba o całościowy sukces projektu, monitoruje stan projektu
\end{itemize}
\question{}{Kto to jest Gold Donor ?}


\begin{framed}
Co oznacza klient TBD (to be determined) ?
\end{framed}
Projekty tworzone w sytuacji gdy klient nie wie jeszcze, że potrzebuje danego systemu, rolę klienta musi pełnić członek zespołu.

\question{}{
Uzasadnij czy metodyka XP może być stosowana w projektach dla klientów TBD. }

\begin{framed}
Co robi konsultant w XP ?
\end{framed}
Konsultant to osoba mająca wiedzę dziedzinową w danej branży, konsultant nie śledzi całego procesu wytwarzania oprogramowania, ale zespół zwraca się do niego z konkretnym problemem.

\begin{framed}
Co robi zarządca w XP ?
\end{framed}
Rolę zarządcy pełni wyłoniony jeden z członków zespołu. Zarządca archiwizuje przebieg prac (zwłaszcza powodzenie testów) oraz analizuje obłożenie prac w poszczególnych iteracjach oszacowując możliwość ukończenia projektu na czas. 
\question{}{
Jakie funkcje XPM są przypisane do roli Zarządca ?
}

\begin{framed}
Co robi trener w XP ?
\end{framed}
Trener to doświadczona osoba, która stymuluje zespół do podejmowania zadań idących we właściwym kierunku poprzez przedstawianie przypadków użycia, które wymagają specjalnej uwagi, a nie są oczywiste. Trener nie narzuca jednak konkretnych rozwiązać.

\subsection{Slajd 17}
\begin{framed}
Z czego składa się planning game, z jakich dwóch etapów ? W którym z tych etapów uczestniczy klient ? Jak często odbywa się planning game ?  Co realizowane jest na każdym z tych etapów ? 
\end{framed}
Występuje przeważnie raz na iterację (np. raz na tydzień). Składa się z dwóch etapów:
\begin{itemize}
\item Release Planning: Z udziałem klienta. Zakłada określenie wymagań stawianych najbliższej wersji oraz terminu jej dostarczenia
\item Planning: Bez udziału klienta. Tu są planowane zadania i aktywności dla członków zespołu. 
\end{itemize}

\subsection{Slajd 18}
\begin{framed}
Z jakich etapów składa się release planning ? Opisz co wykonywane jest w każdej z tych faz.
\end{framed}

Trzy etapy:
\begin{itemize}
\item Exploration Phase: Klient przedstawia listę wysoko wartościowych cech produktu (z jego punktu widzenia). Cechy te zapisywane są na karty „user story”: \\ Write a Story -> Estimate a Story -> Split a Story
\item Commitment Phase: uzgodnienie zakresu prac dla iteracji oraz terminu zakończenia prac: \\ Sort by Value->Sort by Risk->Set Velocity->Choose Scope
\item Steering Phase: Ewentualne korekty planu: dodawanie, modyfikacja lub usuwanie funkcjonalności.
\end{itemize}
\question{}{
Na jakiej podstawie wybierane są historyjki do realizacji w pierwszej kolejności ?
}

\subsection{Slajd 19}
\begin{framed}
Czym jest user story ?
\end{framed}
\begin{itemize}
\item Stanowi jednostkową funkcjonalność w projekcie XP
\item Jest przypomnieniem (udokumentowaniem) konwersacji z klientem
\end{itemize}

\begin{framed}
Jakie są cechy dobrego user story ?
\end{framed}
\begin{itemize}
\item zrozumiała (zarówno dla klienta jak i dewelopera) – najlepiej zapisana w języku naturalnym
\item testowalna
\item wartościowa dla klienta
\item wystarczająco mała, żeby można zaimplementować ich kilka w ciągu jednej iteracji
\item (możliwie) niezależna od innych
\end{itemize}


\subsection{Slajd 20}
Przykłady user stories...

\subsection{Slajd 21}
\begin{framed}
Do czego służy technika CRC Cards (Class, Responsibilities, Collaboration) ? Jak jest realizowana ?
\end{framed}
Karty te opisują części systemu (np. dany moduł, interfejs, integracje modułów), ich celem jest uporządkowanie wszystkich modułów. Karta zawiera nazwę modułu (class), jego funkcje (responsibilities) oraz nazwy modułów z którymi współpracuje (Collaboration). \\ Gdy dane karty opisują przedmioty uzależnione – kładziemy je pod sobą w kolumnie (na wierzchu jest pierwsza rzecz do realizacji). Gdy przedmiot rozważań jest niezależny – kartę kładziemy w kolejnej kolumnie.
\question{}{
 Co oznacza akronim CRC Card? 
}

\subsection{Slajd 22}
\begin{framed}
Z jakich etapów składa się Iteration Planning ? Co się dzieje w każdym z nich ?
\end{framed}
Trzy etapy:
\begin{itemize}
\item Exploration Phase: Wymagania są rozbijane na zadania (tasks). Tworzone są karty z zadaniami.
\item Commitment Phase: Przypisywanie zadań (tasks) do programistów i estymacja (z ich udziałem) czasu potrzebnego na realizację
\item Steering Phase: Zadania są realizowane i efekty ich realizacji są integrowane w ramach realizacji pierwotnej historii użytkownika (user story).
\end{itemize}

\question{}{
W której fazie (podaj jej nazwę) “Iteration Planning” odbywa się estymowanie złożoności danego zadania (tasku)? 
}

\subsection{Slajd 23}
\begin{framed}
Jakie są czynności wykonywane w Steering Phase aby wykonać dane zadanie ?
\end{framed}
\begin{enumerate}
\item Weź taska
\item Znajdź partnera
\item Zaprojektuj taska
\item Napisz test jednostkowy
\item Napisz kod
\item Odpal kod
\item Zrefaktoruj kod
\item (Sprawdź testy akceptacyjne)
\end{enumerate}


\subsection{Slajd 24}
\begin{framed}
Dlaczego pierwsza iteracja ma szczególne znaczenie w XP ?
\end{framed}
\begin{itemize}
\item Definiuje rdzeń systemu na bazie którego będą budowane następne iteracje
\item Ma duże znaczenie we współpracy z klientem ponieważ tworzy pierwsze wrażenie
\end{itemize}

\question{}{
Dlaczego pierwsza iteracja jest tak ważna ?
}

\begin{framed}
Co powinna dostarczać pierwsza iteracja ?
\end{framed}
\begin{itemize}
\item Powinna dostarczyć kilku najbardziej wartościowych historii użytkownika dotyczących podstawowych funkcjonalności
\item Dostarczane historie użytkownika nie powinny zależeć od innych historii nie uwzględnianych w tej iteracji
\item Pierwsza iteracja (z klientem) nie może być iteracją z zerową funkcjonalnością !
\end{itemize}

\subsection{Slajd 25}
\begin{framed}
Do czego służy zerowa iteracja w XP ?
\end{framed}
\begin{itemize}
\item Przygotowanie środowiska pracy (instalacja i konfiguracja środowiska programistycznego, przygotowanie środowiska do testów, system kontroli wersji itp.)
\item Przygotowanie infrastruktury deweloperskiej
\item Zerowa iteracja odbywa się bez klienta, a pierwsza już z klientem
\end{itemize}

\subsection{Slajd 26}
\begin{framed}
Jakie czynności odbywają się periodycznie w ramach planowania iteracji ?
\end{framed}
\begin{itemize}
\item Projektowanie wymagań powstałych po uwzględnieniu User Stories
\item Estymowanie pracochłonności realizacji założeń projektowych opisanych w User Stories
\item Ciągłe uzupełnianie puli rozwiązań technicznych (Spike solutions, np. biblioteki, wzorce projektowe)
\end{itemize}

\subsection{Slajd 27}
\begin{framed}
Czym są Story-Points ? Jak są wyrażane ?
\end{framed}
Story Points używane są do wyceny (estymacji) każdego elementu historii użytkownika. Są to bezjednostkowe punkty przypisywane do każdego zadania. Konieczne jest zdefiniowanie skali Story-Points; kolejne liczby, litery, ciąg Fibonacciego itp.

\question{}{
Co to są Story Points? 
}

\question{}{
 Jakiej miary (pośredniej lub bezpośredniej) używamy do szacowania czasochłonności historyjek ?
}
Trochę nie wiem o co chodzi w tym pytaniu. Z jednej strony User Story są szacowane przez Story Points, skale sobie dobieramy sami. User Story są rozbijane na taski i one znów mają przypisaną estymatę w roboczodniach, czyli idealnych dniach pracy programisty bez zakłóceń... (?)  \\
Oprócz tego na extremeprogramming.org jest napisane:
\begin{figure}[H]
\centerline{\includegraphics[scale=1]{xp4.png}}
\end{figure}
Może więc chodzić o to, że Story Points jako miara pośrednia, a roboczo-tygodnie jako miara bezpośrednia (?).


\subsection{Slajd 28}
\begin{framed}
Opisz technikę Planning Poker
\end{framed}
Służy do estymowania User Stories.
\begin{enumerate}
\item Klient odpowiada na pytania zespołu
\item Każdy członek zespołu określa estymatę (typuje kartę bez jej ujawniania)
\item Głos otrzymuje autor estymaty najwyższej i najniższej
\item Dyskusja jest limitowana czasowo stoperem, po dyskusji następuje kolejna iteracja estymowania aż do uzyskania zgodności
\end{enumerate} 
 
\question{}{
Opisz przebieg estymowania z użyciem techniki “Planning Pokera” 
} 
 
\subsection{Slajd 29}
\begin{framed}
Co oznacza '?' na karcie do planning pokera ? A co oznacza kawa ?
\end{framed}
\begin{itemize}
\item '?' oznacza brak zdania, często sugerujący też, że historia jest zbyt skomplikowana do estymowania
\item Kubek z kawą oznacza prośbę o przerwę
\end{itemize}

\question{}{
Co oznacza znak ‘?’ na kart do Planning Poker ?
}


\subsection{Slajd 30}
\begin{framed}
Wymień zalety planning pokera
\end{framed}
\begin{itemize}
\item Lepsza komunikacja w zespole
\item Lepsza ocena user story przez zaangażowanie wielu osób
\item Możliwość poruszania wątków pokrewnych względem danego user story
\item Zespołowa akceptacja planu do wykonania
\end{itemize}

\subsection{Slajd 31}
Pętla zwrotna XP... 
\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp3.png}}
\end{figure}


\question{}{
Ile standardowo powinna trwać iteracja w XP ?
}
(Od jednego do kilku tygodni)

\subsection{Slajdy 32-37}
\begin{framed}
Wymień 10 praktyk stosowanych w XP
\end{framed}

\begin{itemize}
\item Whole team (jedność zespołu)
\item Kondycja zespołu
\item Informative workplace (Informatywne miejsce pracy)
\item Customer visible functionality (Wartość odczuwalna dla klienta)
\item Planning Game (Iteracyjne planowanie)
\item Pair programming (Programowanie w parach)
\item Spike (Szybkie prototypowanie)
\item Collective code ownership
\item Single code base (Pojedyczna linia oprogramowania)
\item Wysoka jakość wytwarzanego oprogramowania
\end{itemize}

\begin{framed}
Jak realizowana jest praktyka whole team (jedność zespołu) ?
\end{framed}
\begin{itemize}
\item sit together - zespół pracuje razem o ile to możliwe przebywając w jednym pomieszczeniu
\item team continuity - zachowanie ciągłości składu osobowego
\item on-site customer - w skład zespołu wchodzi klient
\end{itemize}

\question{}{
40-hour week, team continuity 
}

\begin{framed}
Jak realizowana jest praktyka kondycja zespołu ?
\end{framed}
\begin{itemize}
\item 40-hour week - brak nadgodzin
\item slack - zezwolenie na pewną swobodę wykorzystania czasu pracy
\item sustainable pace - stałe tempo pracy
\end{itemize}

\question{}{
Za pomocą jakich zasad dbamy o dobrą kondycję zespołu 
}

\question{}{
40-hour week, team continuity 
}

\begin{framed}
Jak realizowana jest praktyka informative workplace (Informatywne miejsce pracy)?
\end{framed}
Informacje istotne dla zespołu są udostępnione bezpośrednio w miejscu pracy zespołu, w sposób umożliwiający wszystkim zainteresowanym nieograniczony dostęp do nich.

\begin{framed}
Jak realizowana jest praktyka wartość odczuwalna (customer visible functionality) ?
\end{framed}
Historie użytkownika rozważa się z punktu widzenia wartości biznesowej, ryzyka, kosztów wytworzenia uzupełnionych o testy akceptacyjne.

\begin{framed}
Jak realizowana jest praktyka iteracyjne planowanie (planning game) ?
\end{framed}
\begin{itemize}
\item Dyskutowane i estymowane są historyjki oraz każda z iteracji, które wchodzą w zakres danego release
\item Na podstawie historyjek tworzy się listę zadań i następuje podjęcie zobowiązania przez programistów (sign-up)
\end{itemize}

\begin{framed}
Jak realizowana jest praktyka pair programming ? Kim jest driver a kim pilot ?
\end{framed}
\begin{itemize}
\item Praca w dwuosobowych zespołach, często zmieniających się
\item Jedna osoba z zespoły zapisuje kod (driver), druga dba o zgodność z projektem, przejrzystość, spójność itp. tworzonego kodu (pilot).
\end{itemize}

\begin{framed}
Jak realizowana jest praktyka szybkie prototypowanie (spike) ?
\end{framed}
Niewiadome i ryzyka w projekcie rozwiązuje się poprzez szybkie prototypowanie (max kilka dni) 

\begin{framed}
Jak realizowana jest praktyka wspólna własność kodu źródłowego (collective code ownership) ?
\end{framed}
Prawo do mydyfikowania \underline{całego} kodu źródłowego utrzymywanego przez zespół mają wszyscy jego członkowie, a nie tylko specjalizujący się w danym fragmencie programiści.

\begin{framed}
Jak realizowana jest praktyka pojedyncza linia oprogramowania (single code base) ?
\end{framed}
Polega na utrzymywaniu pojedynczej bazy kody źródłowego, wspólnej dla wszystkich linii produktu. Robi się to po to aby uniknąć błędów, które często pojawiają się przy wprowadzaniu tej samej poprawki do wielu linii produktu. Nowe funkcjonalności wprowadza się poprzez rozwiązania architektoniczne takie jak mp. konfigurowalne włączanie/wyłączanie funkcjonalności w zależności od odbiorcy końcowego lub platformy docelowej. (np. Firefox ma różne pluginy).

\question{}{
W jaki sposób można pogodzić praktykę single code base z koniecznością istnienia różnych wersji oprogramowania dla różnych odbiorców końcowych ? 
}

\begin{framed}
Jak realizowana jest praktyka  wysoka jakość wytwarzanego oprogramowania ?
\end{framed}
\begin{itemize}
\item Wykorzystanie testów jednostkowych i akceptacyjnych
\item Często konsolidacja całego produktu (continous integration)
\item Testowe wdrożenia (deployment)
\item Aby to zapewnić budowanie systemu powinno nie zabierać więcej niż kilka minut
\end{itemize}

\subsection{Slajd 38}
\begin{framed}
Co oznacza TDD i test first ?
\end{framed}
\begin{itemize}
\item Test first - podejście mówiące, że najpierw tworzymy testy, a potem kod
\item TDD (Test driven development) - określanie funkcjonalności poprzez planowanie testów
\end{itemize}

\begin{framed}
Jakie rodzaje testów przewiduje metodyka XP ?
\end{framed}
\begin{itemize}
\item Testy jednostkowe (unit tests)
\item Testy akceptacyjne (acceptance tests)
\item Testy interaktywne lub wizualne (visual tests)
\end{itemize}
\question{}{
Rodzaje testów w XP}

\subsection{Slajdy 39-40}
\begin{framed}
Omów testy jednostkowe
\end{framed}
\begin{itemize}
\item Tworzone są przez programistów 
\item Są automatyczne
\item Dotyczą każdego elementu do którego można przekazać dane w celu ich przetworzenia
\item Walidują postęp prac 
\end{itemize}

\begin{framed}
Jakie są etapy tworzenia kodu w TDD ?
\end{framed}
\begin{enumerate}
\item Tworzenie kodu
\item Implementacja
\item Refaktoryzacja do standardów, potem znów test
\end{enumerate}

\subsection{Slajd 41}
\begin{framed}
Omów testy akceptacyjne
\end{framed}
\begin{itemize}
\item Są projektowane przez klienta
\item Kodowane są przez programistę gdy klient nie jest w stanie ich samodzielnie wyrazić
\item Opisują oczekiwania klienta wobec powstającego produktu
\item Nazywane są czasem testami funkcjonalnymi 
\end{itemize}

\newpage
\section{Wykład - Testowanie w XPM}

\subsection{Slajd 1}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp5.png}}
\end{figure}

\subsection{Slajd 2}
\begin{framed}
Co rozumiemy przez jednostkę w kontekście programowania ekstremalnego ?
\end{framed}
Jednostka to komponent, klasa, metoda, do testowania jednostek nie jest konieczna integracja projektu.

\subsection{Slajd 3}
Obrazek Eclipse z JUnit...

\subsection{Slajdy 4,5}
\begin{framed}
Za co odpowiada dyrektywa JUnit: \\
@Test public void metoda () 
\end{framed}
Uruchomienie testu metody

\begin{framed}
Za co odpowiada dyrektywa JUnit: \\
@Test (expected = ExceptionClass) public void metoda ()
\end{framed}
Uruchomienie testu metody i sprawdzenie, czy wygenerowała wyjątek ExceptionClass

\begin{framed}
Za co odpowiada dyrektywa JUnit: \\
@Test (timeout=20) public void metoda () 
\end{framed}
Uruchomienie testu metody i pomiar max czasu wykonania (milisekundy).

\begin{framed}
Za co odpowiada dyrektywa JUnit: \\
@Ignore public void metoda () 
\end{framed}
Wyłączenie z testu (np. metody mock)

\begin{framed}
Za co odpowiada dyrektywa JUnit: \\
@Before public void metoda ()...
\end{framed}
Uruchomienie metody przed każdym testem (dla przygotowania środowiska testu – otwarcie pliku, połączenia itp.)

\begin{framed}
Za co odpowiada dyrektywa JUnit: \\
@After public void metoda ()...
\end{framed}
Uruchomienie metody po każdym teście (sprzątanie)


\begin{framed}
Za co odpowiada dyrektywa JUnit: \\
@BeforeClass public void metoda ()...
\end{framed}
Uruchomienie raz dla całego procesu testowania (TestSuite) – dla inicjalizacji testowej wersji „systemu”, ustawiania wartości statycznych.
\question{}{
Do czego typowo w testach tworzonych w JUnit używana jest adnotacja @BeforeClass ?
}

\begin{framed}
Za co odpowiada dyrektywa JUnit: \\
@AfterClass public void metoda ()... 
\end{framed}
Uruchomienie metody jednorazowo po testach


\subsection{Slajd 6}

\begin{framed}
Do czego służy w JUnit asercja: \\
fail(komunikat)
\end{framed}
Bezwarunkowe zakończenie testu niepowodzeniem

\begin{framed}
Do czego służy w JUnit asercja: \\
assertTrue($[$komunikat$]$, boolean wyrażenia)
\end{framed}
Sprawdzenie wyrażenia

\begin{framed}
Do czego służy w JUnit asercja: \\
assertsEquals($[$komunikat$]$, expected, actual) 
\end{framed}
Porównanie dwóch wartości

\begin{framed}
Do czego służy w JUnit asercja: \\
assertNull([komunikat], object), assertNotNull([komunikat], object)
\end{framed}
Sprawdzenie istnienia obiektu 

\begin{framed}
Do czego służy w JUnit asercja: \\
assertSame([komunikat], expected, actual), assertNotSame([komunikat], expected, actual) 
\end{framed}
Sprawdzenie identyczności referencji


\subsection{Slajd 7}
Przykład testu JUnit:

\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp6.png}}
\end{figure}


\subsection{Slajd 8}
\begin{framed}
Czym są tzw. Test Suites w JUnit ?
\end{framed}
Test suite to połączenie wielu testów w jeden proces. 

\begin{framed}
Jakie są dyrektywy używane przez Test Suites ?
\end{framed}
\begin{itemize}
\item @RunWith(Suite.class) - określa, że mamy do czynienia z TestSuite a nie pojedynczy testem
\item @SuiteClasses(\{ PierwszyTest.class, DrugiTest.class \})  - otrzymując listę klas testów powoduje uruchomienie ich w kolejności wyszczególnienia
\end{itemize}

\question{}{
Dlaczego podczas tworzenia programów zgodnie z techniką TDD ważne jest używanie Test Suites ? 
}
\begin{itemize}
\item Umożliwia to automatyzację wykonywania wszystkich testów
\item Umożliwia to łatwe dodawanie kolejnych testów (funkcjonalności) do całego projektu
\item Umożliwia sprawdzenie czy nowo dodana funkcjonalność nie psuje zaimplementowanych dotychczas
\end{itemize}

\subsection{Slajdy 9,10,11}
\begin{framed}
Do czego służą dyrektywy:  \\
@RunWith(Parameterized.class) \\
@Parameters
\end{framed}
Cel: uruchomienie serii testów kodu (np. metody) każdorazowo z różnymi parametrami.
\begin{itemize}
\item @RunWith(Parameterized.class) - przekazanie parametru do konstruktora klasy testu
\item @Parameters - umieszczenie w klasie metody zwracającej tablicowaną kolekcję parametrów i opatrzonej tą dyrektywą
\end{itemize}

Przykład kodu w wykładzie...

\subsection{Slajd 12}
\begin{framed}
Po co stosowany jest Runner w JUnit ?
\end{framed}
Stosowany do uruchomienia testów poza IDE lub w specjalnym trybie

\subsection{Slajdy 13-20}
Na tych slajdach są dyrektywy i asercje, ale tym razem dla NUnit (C\#)...

\subsection{Slajd 21}
\begin{framed}
Czym jest obiekt mock w testach jednostkowych ?
\end{framed}
Mock stosujemy w testach do zasymulowania zachowania klasy jeszcze nie zaimplementowanej. Mock implementuje (wręcz – symuluje) ten sam interfejs, co klasa, jaką zastępuje – podmieniamy ten interfejs w klasie testowanej. Jest konfigurowalny (można przed testem ustalić jego zachowanie).

\question{}{
W jakim celu w testach jednostkowych używa się Mock Objects?
}

\subsection{Slajdy 22-28}
Szersze omówienie stosowania obiektów mock w JUnit i NUnit

\newpage
\section{ Wykład cz.2 }

\subsection{Slajd 1}
\begin{framed}
Czym są Testy wizualne w XP ?
\end{framed}

Komplet wytycznych (zapisanych na przykład w formie listy pozycji do sprawdzenia) umożliwiający sekwencyjne przeprowadzenie wizualnej kontroli funkcjonowania systemu.  Kontrola ta prowadzana jest głównie z punktu widzenia aktorów (użytkowników systemu) i dotyczy oceny interfejsów systemu. W praktyce sprowadza się ona do kontroli ergonomii interfejsów graficznych, lub estetyki prezentowanych za ich pośrednictwem treści.

\subsection{Slajd 2}

\begin{framed}
Pod jakim warunkiem można wykonać modyfikację architektury w XP ?
\end{framed}
Jeśli modyfikacja architektury ułatwi przejście danej iteracji i nie zepsuje wyników testów uzyskanych na poprzednich, należy ją wykonać. \\ Metryka poprawności: Testy jednostkowe (Unit tests)

\subsection{Slajd 3}
\begin{framed}
Jaki jest warunek aktualizacji kodu we wspólnym repozytorium ?
\end{framed}
Warunek aktualizacji kodu w repozytorium: poprawne wykonanie testu jednostki + poprawne wykonanie testu ewentualnej nowej funkcjonalności jednostki

\subsection{Slajdy 4-6}
\begin{framed}
Czym jest i co zawiera dokument standardów kodowania (coding standards) ?
\end{framed}
Specyfikacja standardu powinna być dokumentem krótkim, nie zawierającym zbędnych szczegółów - lecz jednoczenie nie pozostawiającym niedomówień w dziedzinie utrzymywanej konwencji nazewnictwa, formatowania bloków, czy komentowania kodu. 

\subsection{7,8}
\begin{framed}
Na czym polega refaktoryzacja ? Wymień kilka zabiegów stosowanych w refaktoryzacji.
\end{framed}
Refaktoryzacja to zabiegi umożliwiające utrzymanie czytelnej struktury kodu. Do zabiegów należą przykładowo:
\begin{itemize}
\item Korekta nazewnictwa klas, atrybutów, metod
\item Przeniesienie metody do innej klasy
\item Stworzenie nowej metody na podstawie kodu wydzielonego z innej
\item Wyodrębnienie interfejsu z klasy
\item Wydzielenie wartości wyrażenia i zdefiniowanie w postaci stałej
\end{itemize}

\question{}{
Wymień 4 przykłady zabiegów wykonywanych podczas refaktoryzacji. 
}


\subsection{Slajdy 9,10}
\begin{framed}
Za co odpowiada w parze pilot, a za co driver ?
\end{framed}
\begin{itemize}
\item Pomocnik (pilot) dostarcza wiedzę pochodzącą z dokumentacji narzędzi, opracowania merytoryczne rozwiązań zadań, dba o zgodność z projektem, przejrzystość i spójność tworzonego fragmentu oprogramowania.
\item Programista (driver) koduje zapisując kod źródłowy.
\end{itemize}

\subsection{Slajd 11}
Coś o krzywej uczenia...

\subsection{Slajd 12}
\begin{framed}
Czym są stand-up meeting ?
\end{framed}
Spotkanie robocze (stand-up):
\begin{itemize}
\item Codzienne, traktowane jako otwarcie dnia prac
\item Określenie postępu prac - każda para przedstawia tu raport
\item Wykrycie trudnych (wymagających czasu) problemów
\item Koordynacja wysiłków dla rozwiązania trudnych problemów
\end{itemize}


\subsection{Slajd 13}
Single release, że ma zalety, bo jest ciąga integracja, walidacja biznesowa itd. i, że trzeba zintegrować wszystkie testy i przygotować dla klienta do pokazania.

\subsection{Slajd 14-16}

\begin{framed}
Czym jest ciągła integracja (continuous integration) ?
\end{framed}
Ciągła integracja polega na regularnej konsolidacji (łączeniu modułów) i uruchamianiu zestawu testów wielokrotnie w ciągu dnia. Zwykle robi to jedna osoba na oddzielnej maszynie specjalnie dla tego celu. Programista po wykonaniu każdego nowego fragmentu programu łączy go z systemem.

\subsection{Slajd 17}
\begin{framed}
Na czym polega zasada 40 godzinny tydzień pracy ? Czy rzeczywiście musi być to 40 godzin ?
\end{framed}
Jedną z charakterystycznych cech programowania ekstremalnego jest definiowanie sztywnej marszruty czasowej dla programisty, będącą konkretną, nienaruszalną granicą obciążenia grupy. Zwyczajowo nazywamy ją 40-godzinnym tygodniem pracy (40-hour week). Nie jest ważne, ile godzin w tygodniu pracy programisty faktycznie zostało przyjęte jako norma (nie musi to być akurat 40 godzin). Ważne jest, aby norma po wyznaczeniu była utrzymywana ściśle i konsekwentnie. 


\subsection{Slajd 18}
\begin{framed}
Przez jakie stany przechodzi zadanie w procesie jego realizacji ?
\end{framed}
TASK -> DESIGN -> TEST CODE -> TASK CODE -> DEBUG -> BUILD (DONE)

\subsection{Slajd 19}
\begin{framed}
Czy w XP ryzykiem jest opóźnienie realizacji projektu ?
\end{framed}
W małym stopniu, ponieważ zadania są dzielone na krótkie terminy, cały czas mamy kontrolę nad wydaniami i walidacją ze strony klienta.

\subsection{Slajd 20}
\begin{framed}
Czy w XP ryzykiem jest anulowanie projektu ?
\end{framed}
Może się to zdarzyć w powodu czynników niezależnych od stosowania samej metodyki. Dlatego na od klienta wymaga się aby definiował możliwe najmniejsze wartości biznesowe dla poszczególnych release, prowadzi to do mniejszej liczby wydań nieprodukcyjnych i ryzyko anulowania jest dużo mniejsze. 

\subsection{Slajd 21}
\begin{framed}
Czy w XP ryzykiem jest problem rozszerzalności wersji ?
\end{framed}
W XP rozbudowa systemu jest ułatwiona ze względu na wysokie standardy wytwarzanego oprogramowania i ciągłą refaktoryzację.

\subsection{Slajd 22}
\begin{framed}
Czy w XP ryzykiem jest problem niskiej jakości kodu ?
\end{framed}
W XP jest kładziony bardzo duży nacisk na testowanie kodu, co wprowadza wysoką jakość produkowanego kodu.

\subsection{Slajd 23}
\begin{framed}
Czy w XP ryzykiem są nieporozumienia biznesowe ?
\end{framed}
Klient traktowany jest jako część zespołu i cały czas ma wpływ na wymagania. Ponadto nie istnieje formalna specyfikacja wymagań przed rozpoczęciem projektu. Nieporozumienia biznesowe stanowią niskie ryzyko w XP.

\subsection{Slajd 24}
\begin{framed}
Czy w XP ryzykiem są zmiany biznesowe ?
\end{framed}
W XP krótki cykl iteracji redukuje skutki wszystkich zmian biznesowych.


\subsection{Slajd 25}
\begin{framed}
Czy w XP ryzykiem jest niska wartość biznesowa produktu ?
\end{framed}
W XP problem ten jest redukowany poprzez realizację najważniejszych dla klienta wartości biznesowych jako pierwsze.

\subsection{Slajd 26}
\begin{framed}
Czy w XP ryzykiem są rotacje kadrowe ?
\end{framed}
XP wzmacnia kolaborację w zespole, ponadto krótkie czasy trwania realizacji zadań redukują to ryzyko.

\subsection{Slajd 27}
\begin{framed}
Jakie są cechy wspólne XP i SCRUM ?
\end{framed}
\begin{itemize}
\item Samodzielność zespołu
\item Zaangażowanie klienta końcowego
\item Iteracyjne planowanie
\item Regularne dostarczanie działającego oprogramowania
\end{itemize}
\question{}{
Na czym polega 'zwinność' w XP ?
}


\subsection{Slajd 28}
\begin{framed}
Jakie są różnice pomiędzy XP i SCRUM ?
\end{framed}
\begin{itemize}
\item SCRUM dotyczy strony zarządzającej pozostawiając rozwiązania inżynierskie (projektowanie, kodowanie, zarządzanie konfiguracją itp.) zespołowi
\item XP dotyczy posunięć inżynierskich lecz nie dostarcza precyzyjnych narzędzi do zarządznia projektem
\end{itemize}

\subsection{Slajd 29}
Kontrowersje związane z XP (Pair programming, brak dokumentacji...)

\newpage
\section{Wykład - Projektowanie w XPM}

\subsection{Slajd 1}
\begin{framed}
Czym jest projektowanie zwinne w XP ?
\end{framed}
Polega na projektowaniu tylko w niezbędnym zakresie (just enough and no more) z wykorzystaniem architectural spike. Tworzona jest metafora systemu oraz wysokopoziomowa mapa dla całego systemu. \\ Następnie projektowanie odbywa się w sposób ewolucyjny w ramach implementacji poszczególnych zadań. Jest wpisane w cyk deweloperski realizacji zadania.

\subsection{Slajd 2}
\begin{framed}
Czym jest cykl deweloperski realizacji zadania ?
\end{framed}

\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp7.png}}
\end{figure}


\subsection{Slajd 3}
\begin{framed}
Wymień podstawowe zasady projektowania zwinnego w XP
\end{framed}
SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation, Dependency inversion)substitution, Interface segregation, Dependency inversion)
\begin{itemize}
\item Zasada pojedynczej odpowiedzialności (Single Responsibility Principle)
\item Zasada otwarte-zamknięte (Open-Closed Principle)
\item Zasada podstawienia Liskov (Liskov Substitution Principle)
\item Zasada segregacji interfejsów (Interface Segregation Principle) 
\item Zasada odwracania zależności (Dependency Inversion Principle)
\end{itemize}

\subsection{Slajdy 4-8}
\begin{framed}
Na czym polega zasada pojedynczej odpowiedzialności (Single responsibility) ?
\end{framed}
\begin{itemize}
\item Żadna klasa nie może być modyfikowana z więcej niż jednego powoduwięcej niż jednego powodu
\item Jeśli klasa odpowiada za więcej niż jeden obszar to powoduje związanie tych obszarów – obszar to powoduje związanie tych obszarów – klasy powinny podzielić między siebie obszary klasy powinny podzielić między siebie obszary odpowiedzialnościodpowiedzialnośc
\end{itemize}

\subsection{Slajdy 9-12}
\begin{framed}
Na czym polega zasada otwarte-zamknięte (Open closed)?
\end{framed}
Składniki oprogramowania (klasy, moduły, funkcje, itp.) powinny być otwarte na rozbudowę, ale zamknięte dla modyfikacjirozbudowę, ale zamknięte dla modyfikację
\begin{itemize}
\item Otwarcie na rozbudowę – musi istnieć sposób stosunkowo prostej rozbudowy zachowań (funkcjonalności) modułu
\item Zamknięcie dla modyfikacji – rozbudowa zachowań modułu nie może skutkować zmianą kodu źródłowego ani binariów tego modułu
\end{itemize}


\subsection{Slajdy 13-15}
\begin{framed}
Na czym polega zasada podstawienia Barbary Liskov (Liskov Substitution Reinciple)?
\end{framed}
Zasada podstawienia Liskov - musi istnieć możliwość zastępowania typów bazowych ich możliwość zastępowania typów bazowych ich podtypami.podtypami.

\subsection{Slajd 16}
\begin{framed}
Na czym polega zasada segregacji interfejsów (Interface Segregation Principle)?
\end{framed}
\begin{itemize}
\item Eliminowanie „grubych” interfejsów
\item Grube interfejsy należy dzielić - małe grupy metod tworzą poszczególne interfejsy
\item Klient nie powinien być zmuszany do zależności od metod, których nie używazależności od metod, których nie używa
\end{itemize}

\question{}{
 Podaj nazwę zasady, która w akronimie SOLID odpowiada literze 'I' oraz krótko opisz na czym ona polega. 
}

\subsection{Slajd 17-20}
\begin{framed}
Na czym polega zasada odwracania zależności (Dependency Inversion Principle)?
\end{framed}
Moduły wysokopoziomowe nie powinny zależeć od modułów niskopoziomowych. Obie grupy od modułów niskopoziomowych. Obie grupy modułów powinny zależeć od abstrakcjimodułów powinny zależeć od abstrakcji

\section{Wykład - Wzorce projektowe w XPM}

\subsection{Slajdy 1,2}
\begin{framed}
Na czym polega wzorzec Null Object w Agile ?
\end{framed}
\begin{itemize}
\item Założenie: klasa C dostarcza funkcjonalność poprzezinterfejs I. Instancje C są przechowywane w kolekcjach.
\item Oprócz klasy C tworzymy dodatkowa klasę NullC implementującą interfejs I, lecz przygotowaną tak aby implementującą interfejs I, lecz przygotowaną tak aby instancje tej klasy były zwracane po niepowodzeniu wyszukiwania w kolekcji obiektów C (zamiast zwracania wartości null)
\item Wówczas kod zlecający wyszukiwanie nie spowoduje błędu, gdy nie zostanie sprawdzony przypadek zwracania null
\end{itemize}

\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp8.png}}
\end{figure}


\subsection{Slajdy 3,4}
\begin{framed}
Na czym polega wzorzec Factory w Agile ?
\end{framed}
\begin{itemize}
\item Wzorzec faktory jest projektach zwinnych stosowany w celu spełniania reguły DIP (odwracania zależności)
\item Stosowany, gdy spodziewana jest duża liczba wariantów klas wyprowadzonych z abstrakcyjnego wzorca.klas wyprowadzonych z abstrakcyjnego wzorca.
\item Moduł tworzący instancje nie tworzy ich bezpośrednio, lecz korzysta z interfejsu Factory implementowanegoprzez przygotowaną do tego klasę. 
\end{itemize}

\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp9.png}}
\end{figure}
\question{}{
Wzorzec Agile zapewniający zasadę DIP 
}


\subsection{Slajdy 5,6}
\begin{framed}
Na czym polega wzorzec Composite w Agile ?
\end{framed}
\begin{itemize}
\item Popularny w Agile szczególnie w sytuacjach, gdy metody poszczególnych licznych klas wyprowadzonych realizują podobne operacje (np. samo-rysowanie obiektu).
\item Wzorzec zakłada istnienie klasy katalogującej obiekty (przeważnie w postaci kolekcji). 
\item Instancja katalogująca posiada możliwość rejestrowania instancji klas wyprowadzonych
\item Klasa katalogująca implementuje ten sam interfejs co kasy wyprowadzone
\item Dodatkowo klasa katalogująca posiada metody realizujące iteracyjne wywoływanie odpowiednich metod obiektów katalogowanych
\end{itemize}

\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp10.png}}
\end{figure}

\subsection{Slajd 7}
\begin{framed}
Na czym polega wzorzec Observer w Agile ?
\end{framed}
Ogólnie działa to jak Listener w Javie w Swingu, monitorujemy stan obiektu i reagujemy na jego zmianę.


\subsection{Slajd 8}
\begin{framed}
Na czym polega wzorzec Proxy w Agile ?
\end{framed}
Stosowany do kontroli funkcjonowania instancji innej klasy. Typowe zastosowanie to kontrola czasu wykonywania operacji przez instancję kontrolowaną.
\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp11.png}}
\end{figure}


\subsection{Slajdy 9,10}
\begin{framed}
Na czym polega wzorzec Agile dla Abstract Server ?
\end{framed}
\begin{itemize}
\item Kolejne rozwiązanie eliminujące naruszenia DIP (dependency inversion principle).
\item Tworzymy uniwersalny interfejs opisujący czynności, za pomocą których steruje się instancjami klas o podobnych właściwościach. Rezygnujemy zatem z podobnych właściwościach. Rezygnujemy zatem z uzupełniania interfejsów dla specjalnych obiektów sterowanych (na rzecz jednego – uniwersalnego)
\item Niwelowanie skutków stosowania reguły segregacji interfejsów – interfejsy będą agregowane przy pomocy„abstrakcyjnego serwera”
\end{itemize}

\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp12.png}}
\end{figure}


\subsection{Slajdy 11,12}
\begin{framed}
Na czym polega wzorzec State w Agile ?
\end{framed}
\begin{itemize}
\item Bardzo popularny w Agile, definiuje skończoną maszynę stanów dla operacji realizowanych przez system
\item Wzorzec zakłada posiadanie wielu implementacji i przełączanie działania systemu pomiędzy nimi
\item Warunki przeniesione są do oddzielnych klas (powstają klasy warunku implementujące interfejsy, w których określone są metody wykonywane na różne sposoby) 
\item Tworzona jest klasa kontrolna, która otrzymuje nowąinstancję którejś z klas warunku (jako jedna z opcji). Z niej będą wołane odpowiednie implementacje metod
\end{itemize}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp13.png}}
\end{figure}


\subsection{Slajdy 13-15}
\begin{framed}
Czym się różni MVC od MVP ?
\end{framed}
\begin{figure}[H]
\centerline{\includegraphics[scale=0.6]{xp14.png}}
\end{figure}
\begin{itemize}
\item W MVC kontroler obsługuje zdarzenia, manipuluje modelem, który zawiera logikę biznesową, widok wyświetla dane z modelu. Jeden kontroler obsługuje kilka widoków.
\item W MVP dane z modelu są przekazywane do presentera a nie bezpośrednio do widoku, presenter przekazuje je do widoku. Jeden presenter odnosi się do jednego widoku.
\end{itemize}

\question{}{
Które elementy wzorca MVP można testować automatycznie ?
}
Model, presenter. (?)

\section{Pozostałe pytania z kolokwium 2018}


\question{}{
Które diagramy UML są najczęściej wykorzystywane podczas projektowania zwinnego w XPM ?
}
Diagramy klas (?)

\question{}{
Uzasadnij czy w projektach wykonywanych zgodnie z metodyką XPM można oceniać wydajność pracy programisty na podstawie ilości zrealizowanych przez niego zadań (tasków) rejestrowanych na task board. 
}
Raczej nie, pracuje się w parach więc trudno o jednoznaczne określenie ile kto zrobił. 

\end{document}

